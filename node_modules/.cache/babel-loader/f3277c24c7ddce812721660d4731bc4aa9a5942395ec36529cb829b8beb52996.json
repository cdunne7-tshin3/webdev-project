{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\r\n * Copyright (c) 2015-present, Parse, LLC.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n */\n\n/**\r\n * Creates a new Polygon with any of the following forms:<br>\r\n *   <pre>\r\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\r\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\r\n *   </pre>\r\n *\r\n * <p>Represents a coordinates that may be associated\r\n * with a key in a ParseObject or used as a reference point for geo queries.\r\n * This allows proximity-based queries on the key.</p>\r\n *\r\n * <p>Example:<pre>\r\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\r\n *   var object = new Parse.Object(\"PlaceObject\");\r\n *   object.set(\"area\", polygon);\r\n *   object.save();</pre></p>\r\n *\r\n * @alias Parse.Polygon\r\n */\n\nvar ParsePolygon = /*#__PURE__*/function () {\n  /**\r\n   * @param {(number[][] | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\r\n   */\n  function ParsePolygon(coordinates\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/) {\n    (0, _classCallCheck2.default)(this, ParsePolygon);\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n  /**\r\n   * Coordinates value for this Polygon.\r\n   * Throws an exception if not valid type.\r\n   *\r\n   * @property {(number[][] | Parse.GeoPoint[])} coordinates list of coordinates\r\n   * @returns {number[][]}\r\n   */\n\n  (0, _createClass2.default)(ParsePolygon, [{\n    key: \"coordinates\",\n    get: function () /*: Array<Array<number>>*/\n    {\n      return this._coordinates;\n    },\n    set: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/) {\n      this._coordinates = ParsePolygon._validate(coords);\n    }\n    /**\r\n     * Returns a JSON representation of the Polygon, suitable for Parse.\r\n     *\r\n     * @returns {object}\r\n     */\n  }, {\n    key: \"toJSON\",\n    value: function () /*: { __type: string, coordinates: Array<Array<number>> }*/\n    {\n      ParsePolygon._validate(this._coordinates);\n      return {\n        __type: 'Polygon',\n        coordinates: this._coordinates\n      };\n    }\n    /**\r\n     * Checks if two polygons are equal\r\n     *\r\n     * @param {(Parse.Polygon | object)} other\r\n     * @returns {boolean}\r\n     */\n  }, {\n    key: \"equals\",\n    value: function (other\n    /*: mixed*/) /*: boolean*/\n    {\n      if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n        return false;\n      }\n      var isEqual = true;\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\n          isEqual = false;\n          break;\n        }\n      }\n      return isEqual;\n    }\n    /**\r\n     *\r\n     * @param {Parse.GeoPoint} point\r\n     * @returns {boolean} Returns if the point is contained in the polygon\r\n     */\n  }, {\n    key: \"containsPoint\",\n    value: function (point\n    /*: ParseGeoPoint*/) /*: boolean*/\n    {\n      var minX = this._coordinates[0][0];\n      var maxX = this._coordinates[0][0];\n      var minY = this._coordinates[0][1];\n      var maxY = this._coordinates[0][1];\n      for (var i = 1; i < this._coordinates.length; i += 1) {\n        var p = this._coordinates[i];\n        minX = Math.min(p[0], minX);\n        maxX = Math.max(p[0], maxX);\n        minY = Math.min(p[1], minY);\n        maxY = Math.max(p[1], maxY);\n      }\n      var outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n      if (outside) {\n        return false;\n      }\n      var inside = false;\n      for (var _i = 0, j = this._coordinates.length - 1; _i < this._coordinates.length; j = _i++) {\n        var startX = this._coordinates[_i][0];\n        var startY = this._coordinates[_i][1];\n        var endX = this._coordinates[j][0];\n        var endY = this._coordinates[j][1];\n        var intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n      return inside;\n    }\n    /**\r\n     * Validates that the list of coordinates can form a valid polygon\r\n     *\r\n     * @param {Array} coords the list of coordinates to validate as a polygon\r\n     * @throws {TypeError}\r\n     * @returns {number[][]} Array of coordinates if validated.\r\n     */\n  }], [{\n    key: \"_validate\",\n    value: function (coords\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/) /*: Array<Array<number>>*/\n    {\n      if (!(0, _isArray.default)(coords)) {\n        throw new TypeError('Coordinates must be an Array');\n      }\n      if (coords.length < 3) {\n        throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n      }\n      var points = [];\n      for (var i = 0; i < coords.length; i += 1) {\n        var coord = coords[i];\n        var geoPoint = void 0;\n        if (coord instanceof _ParseGeoPoint.default) {\n          geoPoint = coord;\n        } else if ((0, _isArray.default)(coord) && coord.length === 2) {\n          geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n        } else {\n          throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n        }\n        points.push([geoPoint.latitude, geoPoint.longitude]);\n      }\n      return points;\n    }\n  }]);\n  return ParsePolygon;\n}();\nvar _default = ParsePolygon;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_isArray","_classCallCheck2","_createClass2","_defineProperty2","_ParseGeoPoint","ParsePolygon","coordinates","_coordinates","_validate","key","get","set","coords","__type","other","length","isEqual","i","point","minX","maxX","minY","maxY","p","Math","min","max","outside","latitude","longitude","inside","_i","j","startX","startY","endX","endY","intersect","TypeError","points","coord","geoPoint","push","_default"],"sources":["C:/Users/chtdu/Documents/WEB DEV/git-repo/react-webpack8/node_modules/parse/lib/browser/ParsePolygon.js"],"sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\r\n\r\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\r\n\r\n_Object$defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nexports.default = void 0;\r\n\r\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\r\n\r\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\r\n\r\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\r\n\r\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\r\n\r\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\r\n/**\r\n * Copyright (c) 2015-present, Parse, LLC.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @flow\r\n */\r\n\r\n/**\r\n * Creates a new Polygon with any of the following forms:<br>\r\n *   <pre>\r\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\r\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\r\n *   </pre>\r\n *\r\n * <p>Represents a coordinates that may be associated\r\n * with a key in a ParseObject or used as a reference point for geo queries.\r\n * This allows proximity-based queries on the key.</p>\r\n *\r\n * <p>Example:<pre>\r\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\r\n *   var object = new Parse.Object(\"PlaceObject\");\r\n *   object.set(\"area\", polygon);\r\n *   object.save();</pre></p>\r\n *\r\n * @alias Parse.Polygon\r\n */\r\n\r\n\r\nvar ParsePolygon = /*#__PURE__*/function () {\r\n  /**\r\n   * @param {(number[][] | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\r\n   */\r\n  function ParsePolygon(coordinates\r\n  /*: Array<Array<number>> | Array<ParseGeoPoint>*/\r\n  ) {\r\n    (0, _classCallCheck2.default)(this, ParsePolygon);\r\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\r\n    this._coordinates = ParsePolygon._validate(coordinates);\r\n  }\r\n  /**\r\n   * Coordinates value for this Polygon.\r\n   * Throws an exception if not valid type.\r\n   *\r\n   * @property {(number[][] | Parse.GeoPoint[])} coordinates list of coordinates\r\n   * @returns {number[][]}\r\n   */\r\n\r\n\r\n  (0, _createClass2.default)(ParsePolygon, [{\r\n    key: \"coordinates\",\r\n    get: function ()\r\n    /*: Array<Array<number>>*/\r\n    {\r\n      return this._coordinates;\r\n    },\r\n    set: function (coords\r\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\r\n    ) {\r\n      this._coordinates = ParsePolygon._validate(coords);\r\n    }\r\n    /**\r\n     * Returns a JSON representation of the Polygon, suitable for Parse.\r\n     *\r\n     * @returns {object}\r\n     */\r\n\r\n  }, {\r\n    key: \"toJSON\",\r\n    value: function ()\r\n    /*: { __type: string, coordinates: Array<Array<number>> }*/\r\n    {\r\n      ParsePolygon._validate(this._coordinates);\r\n\r\n      return {\r\n        __type: 'Polygon',\r\n        coordinates: this._coordinates\r\n      };\r\n    }\r\n    /**\r\n     * Checks if two polygons are equal\r\n     *\r\n     * @param {(Parse.Polygon | object)} other\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"equals\",\r\n    value: function (other\r\n    /*: mixed*/\r\n    )\r\n    /*: boolean*/\r\n    {\r\n      if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\r\n        return false;\r\n      }\r\n\r\n      var isEqual = true;\r\n\r\n      for (var i = 1; i < this._coordinates.length; i += 1) {\r\n        if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\r\n          isEqual = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      return isEqual;\r\n    }\r\n    /**\r\n     *\r\n     * @param {Parse.GeoPoint} point\r\n     * @returns {boolean} Returns if the point is contained in the polygon\r\n     */\r\n\r\n  }, {\r\n    key: \"containsPoint\",\r\n    value: function (point\r\n    /*: ParseGeoPoint*/\r\n    )\r\n    /*: boolean*/\r\n    {\r\n      var minX = this._coordinates[0][0];\r\n      var maxX = this._coordinates[0][0];\r\n      var minY = this._coordinates[0][1];\r\n      var maxY = this._coordinates[0][1];\r\n\r\n      for (var i = 1; i < this._coordinates.length; i += 1) {\r\n        var p = this._coordinates[i];\r\n        minX = Math.min(p[0], minX);\r\n        maxX = Math.max(p[0], maxX);\r\n        minY = Math.min(p[1], minY);\r\n        maxY = Math.max(p[1], maxY);\r\n      }\r\n\r\n      var outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\r\n\r\n      if (outside) {\r\n        return false;\r\n      }\r\n\r\n      var inside = false;\r\n\r\n      for (var _i = 0, j = this._coordinates.length - 1; _i < this._coordinates.length; j = _i++) {\r\n        var startX = this._coordinates[_i][0];\r\n        var startY = this._coordinates[_i][1];\r\n        var endX = this._coordinates[j][0];\r\n        var endY = this._coordinates[j][1];\r\n        var intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\r\n\r\n        if (intersect) {\r\n          inside = !inside;\r\n        }\r\n      }\r\n\r\n      return inside;\r\n    }\r\n    /**\r\n     * Validates that the list of coordinates can form a valid polygon\r\n     *\r\n     * @param {Array} coords the list of coordinates to validate as a polygon\r\n     * @throws {TypeError}\r\n     * @returns {number[][]} Array of coordinates if validated.\r\n     */\r\n\r\n  }], [{\r\n    key: \"_validate\",\r\n    value: function (coords\r\n    /*: Array<Array<number>> | Array<ParseGeoPoint>*/\r\n    )\r\n    /*: Array<Array<number>>*/\r\n    {\r\n      if (!(0, _isArray.default)(coords)) {\r\n        throw new TypeError('Coordinates must be an Array');\r\n      }\r\n\r\n      if (coords.length < 3) {\r\n        throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\r\n      }\r\n\r\n      var points = [];\r\n\r\n      for (var i = 0; i < coords.length; i += 1) {\r\n        var coord = coords[i];\r\n        var geoPoint = void 0;\r\n\r\n        if (coord instanceof _ParseGeoPoint.default) {\r\n          geoPoint = coord;\r\n        } else if ((0, _isArray.default)(coord) && coord.length === 2) {\r\n          geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\r\n        } else {\r\n          throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\r\n        }\r\n\r\n        points.push([geoPoint.latitude, geoPoint.longitude]);\r\n      }\r\n\r\n      return points;\r\n    }\r\n  }]);\r\n  return ParsePolygon;\r\n}();\r\n\r\nvar _default = ParsePolygon;\r\nexports.default = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}